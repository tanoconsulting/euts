#!/usr/bin/env bash

# Manage the whole set of containers and run tests without having to learn Docker

# consts
BOOTSTRAP_OK_FILE=/var/run/bootstrap_ok
DEFAULT_CONTAINER_USER_UID=1000
DEFAULT_CONTAINER_USER_GID=1000
WEB_USER=test
DEFAULT_CONFIG_FILE=.euts.env
# vars
BOOTSTRAP_TIMEOUT=600
CLEANUP_UNUSED_IMAGES=false
CONFIG_FILE=
DOCKER_COMPOSE=docker-compose
DOCKER_NO_CACHE=
INTERACTIVE=
PARALLEL_BUILD=
PULL_IMAGES=false
REBUILD=false
RECREATE=false
RESET=
SETUP_APP_ON_BOOT=
SILENT=false
TTY=
VERBOSITY=
WEB_CONTAINER=

help() {
    printf "Usage: teststack [OPTIONS] COMMAND [OPTARGS]

Manages the Test Environment Docker Stack

Commands:
    build             build or rebuild the complete set of containers and set up eZ. Leaves the stack running
    cleanup WHAT      remove temporary data/logs/caches/etc... CATEGORY can be any of:
                        - data            NB: this removes all your data! Better done when containers are stopped
                        - docker-images   removes only unused images. Can be quite beneficial to free up space
                        - docker-logs     NB: for this to work, you'll need to run this script as root
                        - ez-cache
                        - ez-logs
                        - logs            removes log files from the databases, webservers
    console \$cmd      run a Symfony console command in the test container
    dbconsole         connect to the eZ database for an interactive session
    enter             run a shell in the test container
    exec \$cmd         execute a single shell command in the test container
    images [\$svc]     list container images
    kill [\$svc]       kill containers
    logs [\$svc]       view output from containers
    pause [\$svc]      pause the containers
    ps [\$svc]         show the status of running containers
    setup             set up eZ without rebuilding the containers first
    resetdb           resets the database used for testing (normally executed as part of provisioning)
    runtests [\$suite] execute the test suite using the test container (or a single test scenario eg. Tests/phpunit/05_TagsTest.php)
    services          list docker-compose services
    start [\$svc]      start the complete set of containers
    stop [\$svc]       stop the complete set of containers
    top [\$svc]        display the running container processes
    unpause [\$svc]    unpause the containers

Options:
    -e FILE           name of an environment file to use instead of .euts.env (has to be used for 'start', not for 'exec' or 'enter').
                      Path relative to the docker folder.
                      The env var TESTSTACK_CONFIG_FILE can also be used as an alternative to this option.
    -h                print help
    -r                reset the eZ database and caches - when running 'runtests'. NB: this wipes all your data!
    -v                verbose mode

Advanced Options:
    -c                clean up docker images which have become useless - when running 'build'
    -d                discard existing containers and force them to rebuild from scratch (this forces a full app set up as well) - when running 'build'
    -f                freshen: force app set up via resetting containers to clean-build status besides updating them if needed - when running 'build'
    -i                interactive - when running 'exec'
    -n                do not set up the app - when running 'build', 'start'
    -s                force the app to be set up - when running 'build', 'start'
    -t                 Allocate a pseudo-TTY - when running 'exec'
    -u                update (pull) the container base images (this might force a rebuild) - when running 'build'
    -w SECONDS        wait timeout for completion of app and container set up - when running 'build', 'start' and 'setup'. Defaults to ${BOOTSTRAP_TIMEOUT}
    -z                avoid using docker cache - when running 'build -r'
"
}

create_compose_command() {
    DOCKER_COMPOSE="${DOCKER_COMPOSE} -f docker-compose.yml -f docker-compose-${DB_TYPE}.yml"
    DOCKER_TESTSTACK_QUIET=${DOCKER_COMPOSE/ --verbose/}
}

build() {

    # q: do we really need to do this here?
    if [ ${CLEANUP_UNUSED_IMAGES} = 'true' ]; then
        cleanup_dead_docker_images
    fi

    echo "[$(date)] Stopping running Containers..."

    ${DOCKER_COMPOSE} stop

    if [ ${REBUILD} = 'true' ]; then
        echo "[$(date)] Removing existing Containers..."

        ${DOCKER_COMPOSE} rm -f
    fi

    if [ ${PULL_IMAGES} = 'true' ]; then
        echo "[$(date)] Pulling base Docker images..."
        # @todo make this flexible enough to accommodate any base image
        # 1 get list of images
        # 2 for each, run 'docker image history $img', remove <missing>
        # 3 take last image id, run `docker image ls | grep f6dcff9b59af`, take the first 2 cols (or use `docker image inspect --format='{{index .RepoTags 0}}`)
        if [ -n "${TESTSTACK_OS_VENDOR}" ]; then
            DIMG="${TESTSTACK_OS_VENDOR}:${TESTSTACK_DEBIAN_VERSION}"
        else
            if [ -n "${TESTSTACK_DEBIAN_VERSION}" ]; then
                DIMG="debian:${TESTSTACK_DEBIAN_VERSION}"
            else
                DIMG="debian:buster"
            fi
        fi
        if [ -n "${MYSQL_VERSION}" ]; then
            MIMG="mysql:${MYSQL_VERSION}"
        else
            MIMG="mysql:5.6"
        fi
        if [ -n "${POSTGRESQL_VERSION}" ]; then
            PIMG="postgres:${POSTGRESQL_VERSION}"
        else
            PIMG="postgres:9.5"
        fi
        IMAGES="${DIMG} ${MIMG} ${PIMG}"
        for IMAGE in $IMAGES; do
            docker pull $IMAGE
        done
    fi

    echo "[$(date)] Building Containers..."

    ${DOCKER_COMPOSE} build ${PARALLEL_BUILD} ${DOCKER_NO_CACHE} || exit $?

    # q: do we really need to have 2 different env vars and an EXPORT call?
    if [ "${SETUP_APP_ON_BOOT}" != '' ]; then
        export TESTSTACK_SETUP_APP_ON_BOOT=${SETUP_APP_ON_BOOT}
    fi

    echo "[$(date)] Starting Containers..."

    if [ ${RECREATE} = 'true' ]; then
        ${DOCKER_COMPOSE} up -d --force-recreate || exit $?
    else
        ${DOCKER_COMPOSE} up -d || exit $?
    fi

    wait_for_bootstrap all
    RETCODE=$?

    if [ ${CLEANUP_UNUSED_IMAGES} = 'true' ]; then
        cleanup_dead_docker_images
    fi

    if [ $RETCODE -eq 0 -a "${SETUP_APP_ON_BOOT}" != skip ]; then
        RETCODE=$(docker exec "${WEB_CONTAINER}" cat /home/test/setup_ok)
    fi

    if [ $RETCODE -eq 0 ]; then
        echo "[$(date)] Build finished"
    else
        echo "[$(date)] Build finished. Exit code: ${RETCODE}"
    fi

    exit ${RETCODE}
}

check_requirements() {
    which docker >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        printf "\n\e[31mPlease install docker & add it to \$PATH\e[0m\n\n" >&2
        exit 1
    fi

    which docker-compose >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        printf "\n\e[31mPlease install docker-compose & add it to \$PATH\e[0m\n\n" >&2
        exit 1
    fi
}

# @todo loop over all args instead of allowing just one
cleanup() {
    case "${1}" in
        data)
            if [ ${SILENT} != true ]; then
                echo "Do you really want to delete all database data?"
                select yn in "Yes" "No"; do
                    case $yn in
                        Yes ) break ;;
                        No ) exit 1 ;;
                    esac
                done
            fi

            find ./data/ -type f ! -name .gitkeep -delete
            # leftover sockets happen...
            find ./data/ -type s -delete
            find ./data/ -type d -empty -delete
        ;;
        docker-images)
            cleanup_dead_docker_images
        ;;
        docker-logs)
            for CONTAINER in $(${DOCKER_TESTSTACK_QUIET} ps -q)
            do
                LOGFILE=$(docker inspect --format='{{.LogPath}}' ${CONTAINER})
                if [ -n "${LOGFILE}" ]; then
                    echo "" > ${LOGFILE}
                fi
            done
        ;;
        ez-cache)
            docker exec  "${WEB_CONTAINER}" su "${WEB_USER}" -c "../teststack/bin/cleanup.sh ez-cache"
        ;;
        ez-logs)
            docker exec "${WEB_CONTAINER}" su "${WEB_USER}" -c "../teststack/bin/cleanup.sh ez-logs"
        ;;
        logs)
            find ./logs/ -type f ! -name .gitkeep -delete
            #find ../app/var/log/ -type f ! -name .gitkeep -delete
        ;;
        *)
            printf "\n\e[31mERROR:\e[0m unknown cleanup target ${1}\n\n" >&2
            help
            exit 1
        ;;
    esac
}

cleanup_dead_docker_images() {
    echo "[$(date)] Removing unused Docker images from disk..."
    DEAD_IMAGES=$(docker images | grep "<none>" | awk "{print \$3}")
    if [ -n "${DEAD_IMAGES}" ]; then
        docker rmi ${DEAD_IMAGES}
    fi
}

# @todo add support for setting up file Tests/docker/data/.composer/auth.json
create_default_config() {
    if [ ! -f ${DEFAULT_CONFIG_FILE} ]; then
        echo "[$(date)] Setting up the configuration file '${DEFAULT_CONFIG_FILE}'..."

        CURRENT_USER_UID=$(id -u)
        CURRENT_USER_GID=$(id -g)

        touch ${DEFAULT_CONFIG_FILE}

        # @todo in case the file already has these vars, replace them instead of appending!
        if [ "${DEFAULT_CONTAINER_USER_UID}" != "${CURRENT_USER_UID}" ]; then
            echo "CONTAINER_USER_UID=${CURRENT_USER_UID}" >> ${DEFAULT_CONFIG_FILE}
        fi
        if [ "${DEFAULT_CONTAINER_USER_GID}" != "${CURRENT_USER_GID}" ]; then
            echo "CONTAINER_USER_GID=${CURRENT_USER_GID}" >> ${DEFAULT_CONFIG_FILE}
        fi
    fi
}

dotenv() {
    if [ ! -f "${1}" ]; then
        printf "\n\e[31mERROR:\e[0m configuration file '${1}' not found\n\n" >&2

        exit 1
    fi
    set -a
        . "${1}"
    set +a

    # BC with versions 0.1 - 0.2
    if [ -z "${COMPOSE_PROJECT_NAME}" -a -n "${TESTSTACK_PROJECT_NAME}" ]; then
        export COMPOSE_PROJECT_NAME="${TESTSTACK_PROJECT_NAME}"
    fi
}

load_config() {
    if [ -z "${CONFIG_FILE}" ]; then
        CONFIG_FILE=${DEFAULT_CONFIG_FILE}
    fi

    if [ -n "${VERBOSITY}" ]; then
        echo "Using config file: ${CONFIG_FILE}"
    fi

    dotenv ${CONFIG_FILE}

    # same default as in docker-compose.yml
    if [ -z "${DB_TYPE}" ]; then
        DB_TYPE=mysql
    fi

    create_compose_command

    # @todo check UID, GID from conf vs. current. If different, ask for confirmation before running
    #if []; then
    #fi
}

setup_app() {
    echo "[$(date)] Starting all Containers..."

    # avoid automatic app setup being triggered here
    export TESTSTACK_SETUP_APP_ON_BOOT=skip
    ${DOCKER_COMPOSE} up -d || exit $?

    wait_for_bootstrap all || exit $?

    echo "[$(date)] Setting up the Application..."
    docker exec "${WEB_CONTAINER}" /root/boot/symlinkvendors.sh
    docker exec "${WEB_CONTAINER}" su "${WEB_USER}" -c "cd /home/test/bundle && ../teststack/bin/setup.sh; echo \$? > /home/test/setup_ok"

    # @bug WEB_CONTAINER is not defined in subshell ?
    RETCODE=$(docker exec "${WEB_CONTAINER}" cat /home/test/setup_ok)
    echo "[$(date)] Setup finished. Exit code: ${RETCODE}"

    return $RETCODE
}

# Wait until containers have fully booted
wait_for_bootstrap() {

    if [ ${BOOTSTRAP_TIMEOUT} -le 0 ]; then
        return 0
    fi

    case "${1}" in
        all)
            # q: check all services or only the running ones?
            #BOOTSTRAP_CONTAINERS=$(${DOCKER_TESTSTACK_QUIET} config --services)
            BOOTSTRAP_CONTAINERS=$(${DOCKER_TESTSTACK_QUIET} ps --services | tr '\n' ' ')
        ;;
        app)
            BOOTSTRAP_CONTAINERS='ez'
        ;;
        *)
            #printf "\n\e[31mERROR:\e[0m unknown booting container: '${1}'\n\n" >&2
            #help
            #exit 1
            # @todo add check that this service is actually defined
            BOOTSTRAP_CONTAINERS=${1}
        ;;
    esac

    echo "[$(date)] Waiting for containers bootstrap to finish: ${BOOTSTRAP_CONTAINERS}..."

     START_TIME=$SECONDS
     ELAPSED=0
     i=0
     while [ $ELAPSED -le "${BOOTSTRAP_TIMEOUT}" ]; do
        sleep 1
        BOOTSTRAP_OK=''
        for BS_CONTAINER in ${BOOTSTRAP_CONTAINERS}; do
            printf "Waiting for ${BS_CONTAINER} ... "
            # @todo fix this check for the case of container not running / tty issues / etc...
            #       Eg. use instead a check such as `bash -c 'ps auxwww | fgrep "tail -f /dev/null" | fgrep -v grep'` ?
            OUT=$(${DOCKER_TESTSTACK_QUIET} exec -T ${BS_CONTAINER} cat ${BOOTSTRAP_OK_FILE} 2>&1)
            RETCODE=$?
            if [ ${RETCODE} -eq 0 ]; then
                printf "\e[32mdone\e[0m\n"
                BOOTSTRAP_OK="${BOOTSTRAP_OK} ${BS_CONTAINER}"
            else
                echo
                # to debug:
                #echo $OUT;
            fi
        done
        if [ -n "${BOOTSTRAP_OK}" ]; then
            for BS_CONTAINER in ${BOOTSTRAP_OK}; do
                BOOTSTRAP_CONTAINERS=${BOOTSTRAP_CONTAINERS//${BS_CONTAINER}/}
            done
            if [ -z  "${BOOTSTRAP_CONTAINERS// /}" ]; then
                break
            fi
        fi
        i=$(( i + 1 ))
        ELAPSED=$(( SECONDS - START_TIME ))
    done
    if [ $i -gt 0 ]; then echo; fi

    if [ -n "${BOOTSTRAP_CONTAINERS// /}" ]; then
        printf "\n\e[31mBootstrap process did not finish within ${BOOTSTRAP_TIMEOUT} seconds\e[0m\n\n" >&2
        # @todo we could show the docker logs
        return 1
    fi

    return 0
}

# @todo move to a function
# @todo allow parsing of cli options after args -- see fe. https://medium.com/@Drew_Stokes/bash-argument-parsing-54f3b81a6a8f
while getopts ":cde:fhinrstuvw:yz" opt
do
    case $opt in
        c)
            CLEANUP_UNUSED_IMAGES=true
        ;;
        d)
            REBUILD=true
        ;;
        e)
            CONFIG_FILE=${OPTARG}
        ;;
        f)
            RECREATE=true
        ;;
        h)
            help
            exit 0
        ;;
        i)
            INTERACTIVE='-i'
        ;;
        n)
            SETUP_APP_ON_BOOT=skip
        ;;
        r)
            RESET=-r
        ;;
        s)
            SETUP_APP_ON_BOOT=force
        ;;
        t)
            TTY='-t'
        ;;
        u)
            PULL_IMAGES=true
        ;;
        v)
            VERBOSITY=-v
            DOCKER_COMPOSE="${DOCKER_COMPOSE} --verbose"
        ;;
        w)
            BOOTSTRAP_TIMEOUT=${OPTARG}
        ;;
        y)
            SILENT=true
        ;;
        z)
            DOCKER_NO_CACHE=--no-cache
        ;;
        \?)
            printf "\n\e[31mERROR:\e[0m unknown option '-${OPTARG}'\n\n" >&2
            help
            exit 1
        ;;
    esac
done
shift $((OPTIND-1))

COMMAND=$1

check_requirements

if [ -z "${CONFIG_FILE}" ]; then
    if [ ! -z "${TESTSTACK_CONFIG_FILE}" ]; then
        CONFIG_FILE=${TESTSTACK_CONFIG_FILE}
    fi
fi

if [ -z "${CONFIG_FILE}" ]; then
    create_default_config
fi

load_config

# @todo allow installation of the Test Stack elsewhere than as direct subfolder of the project
#TESTSTACK_DIR=$(basename -- $(dirname -- ${BASH_SOURCE[0]}))

cd $(dirname -- ${BASH_SOURCE[0]})/docker

# Since the line below relies on knowing the contents of the yml file anyway, let's be more efficient...
#WEB_CONTAINER=$(${DOCKER_TESTSTACK_QUIET} config | grep 'container_name: .*_ez$' | sed -e 's/ \+container_name: \+//g')
WEB_CONTAINER=${COMPOSE_PROJECT_NAME:-euts}_ez

case "${COMMAND}" in
    build)
        build
    ;;

    cleanup)
        # @todo allow to pass many cleanup targets in one go
        cleanup "${2}"
    ;;

    config)
        ${DOCKER_COMPOSE} config ${2}
    ;;

    console | ezconsole | sfconsole)
        # @todo allow this to be run from within the test container too
        docker exec -ti "${WEB_CONTAINER}" su "${WEB_USER}" -c '../teststack/bin/sfconsole.sh "$@"' -- "$@"
    ;;

    dbconsole | dbcli | dbclient)
        # @todo allow this to be run from within the test container too
        docker exec -ti "${WEB_CONTAINER}" su "${WEB_USER}" -c '../teststack/bin/dbconsole.sh "$@"' -- "$@"
    ;;

    # courtesy command alias - same as 'ps'
    containers)
        ${DOCKER_COMPOSE} ps ${2}
    ;;

    enter | shell | cli)
        docker exec -ti "${WEB_CONTAINER}" su "${WEB_USER}"
    ;;

    exec)
        # scary line ? found it at https://stackoverflow.com/questions/12343227/escaping-bash-function-arguments-for-use-by-su-c
        shift
        docker exec $INTERACTIVE $TTY "${WEB_CONTAINER}" su "${WEB_USER}" -c '"$0" "$@"' -- exec "$@"
    ;;

    images)
        ${DOCKER_COMPOSE} images ${2}
    ;;

    kill)
        ${DOCKER_COMPOSE} kill ${2}
    ;;

    logs)
        ${DOCKER_COMPOSE} logs ${2}
    ;;

    pause)
        ${DOCKER_COMPOSE} pause ${2}
    ;;

    ps)
        ${DOCKER_COMPOSE} ps ${2}
    ;;

    resetdb)
        # @todo allow this to be run from within the test container too
        # q: do we need -ti ?
        docker exec "${WEB_CONTAINER}" su "${WEB_USER}" -c "../teststack/bin/create-db.sh"
    ;;

    runtests)
        shift
        # q: do we need -ti ?
        docker exec "${WEB_CONTAINER}" su "${WEB_USER}" -c '"$0" "$@"' -- ../teststack/bin/runtests.sh ${RESET} ${VERBOSITY} "$@"
    ;;

    setup)
        if [ "${SETUP_APP_ON_BOOT}" != '' ]; then
            # avoid user confusion
            printf "\n\e[31mERROR:\e[0m -s and -n flags should not be used with the setup command\n\n" >&2
            exit 1
        fi
        setup_app
        exit $?
    ;;

    services)
        ${DOCKER_COMPOSE} config --services | sort
    ;;

    start)
        if [ "${SETUP_APP_ON_BOOT}" != '' ]; then
            export TESTSTACK_SETUP_APP_ON_BOOT=${SETUP_APP_ON_BOOT}
        fi
        ${DOCKER_COMPOSE} up -d ${2} || exit $?

        if [ -z "${2}" ]; then
            wait_for_bootstrap all
            exit $?
        else
            wait_for_bootstrap ${2}
            exit $?
        fi
    ;;

    stop)
        ${DOCKER_COMPOSE} stop ${2}
    ;;

    top)
        ${DOCKER_COMPOSE} top ${2}
    ;;

    unpause)
        ${DOCKER_COMPOSE} unpause ${2}
    ;;

    *)
        printf "\n\e[31mERROR:\e[0m unknown command '${COMMAND}'\n\n" >&2
        help
        exit 1
    ;;
esac
